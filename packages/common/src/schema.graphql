schema {
  query: Queries
  mutation: Mutations
}

# Directs the executor to query only when the field exists.
directive @ifdef on FIELD

type BatchInboundShipmentResponse {
  insertInboundShipments: [InsertInboundShipmentResponseWithId!]
  insertInboundShipmentLines: [InsertInboundShipmentLineResponseWithId!]
  updateInboundShipmentLines: [UpdateInboundShipmentLineResponseWithId!]
  deleteInboundShipmentLines: [DeleteInboundShipmentLineResponseWithId!]
  updateInboundShipments: [UpdateInboundShipmentResponseWithId!]
  deleteInboundShipments: [DeleteInboundShipmentResponseWithId!]
}

type BatchIsReserved implements DeleteInboundShipmentLineErrorInterface & UpdateInboundShipmentLineErrorInterface {
  description: String!
}

type BatchOutboundShipmentResponse {
  insertOutboundShipments: [InsertOutboundShipmentResponseWithId!]
  insertOutboundShipmentLines: [InsertOutboundShipmentLineResponseWithId!]
  updateOutboundShipmentLines: [UpdateOutboundShipmentLineResponseWithId!]
  deleteOutboundShipmentLines: [DeleteOutboundShipmentLineResponseWithId!]
  updateOutboundShipments: [UpdateOutboundShipmentResponseWithId!]
  deleteOutboundShipments: [DeleteOutboundShipmentResponseWithId!]
}

type CanOnlyEditInvoicesInLoggedInStoreError implements UpdateOutboundShipmentErrorInterface {
  description: String!
}

type CannotChangeInvoiceBackToDraft implements UpdateInboundShipmentErrorInterface {
  description: String!
}

type CannotChangeStatusBackToDraftError implements UpdateOutboundShipmentErrorInterface {
  description: String!
}

type CannotChangeStatusOfInvoiceOnHold implements UpdateOutboundShipmentErrorInterface & UpdateInboundShipmentErrorInterface {
  description: String!
}

type CannotDeleteInvoiceWithLines implements DeleteInboundShipmentErrorInterface & DeleteOutboundShipmentErrorInterface {
  description: String!
  lines: InvoiceLineConnector!
}

type CannotEditFinalisedInvoice implements DeleteInboundShipmentLineErrorInterface & UpdateOutboundShipmentLineErrorInterface & InsertOutboundShipmentLineErrorInterface & DeleteOutboundShipmentLineErrorInterface & UpdateInboundShipmentLineErrorInterface & DeleteInboundShipmentErrorInterface & DeleteOutboundShipmentErrorInterface & InsertInboundShipmentLineErrorInterface & UpdateInboundShipmentErrorInterface {
  description: String!
}

# Generic Error Wrapper
type ConnectorError {
  error: ConnectorErrorInterface!
}

interface ConnectorErrorInterface {
  description: String!
}

type DatabaseError implements ConnectorErrorInterface & InsertOutboundShipmentLineErrorInterface & NodeErrorInterface & UpdateOutboundShipmentLineErrorInterface & InsertInboundShipmentErrorInterface & DeleteOutboundShipmentLineErrorInterface & UpdateInboundShipmentErrorInterface & DeleteOutboundShipmentErrorInterface & InsertInboundShipmentLineErrorInterface & DeleteInboundShipmentErrorInterface & UpdateInboundShipmentLineErrorInterface & InsertOutboundShipmentErrorInterface & UpdateOutboundShipmentErrorInterface & DeleteInboundShipmentLineErrorInterface {
  description: String!
  fullError: String!
}

# Implement the DateTime<Utc> scalar
#
# The input/output is a string in RFC3339 format.
scalar DateTime

input DatetimeFilterInput {
  equalTo: DateTime
  beforeOrEqualTo: DateTime
  afterOrEqualTo: DateTime
}

# Generic Error Wrapper
type DeleteInboundShipmentError {
  error: DeleteInboundShipmentErrorInterface!
}

interface DeleteInboundShipmentErrorInterface {
  description: String!
}

input DeleteInboundShipmentInput {
  id: String!
}

# Generic Error Wrapper
type DeleteInboundShipmentLineError {
  error: DeleteInboundShipmentLineErrorInterface!
}

interface DeleteInboundShipmentLineErrorInterface {
  description: String!
}

input DeleteInboundShipmentLineInput {
  id: String!
  invoiceId: String!
}

union DeleteInboundShipmentLineResponse =
    DeleteInboundShipmentLineError
  | DeleteResponse

type DeleteInboundShipmentLineResponseWithId {
  id: String!
  response: DeleteInboundShipmentLineResponse!
}

union DeleteInboundShipmentResponse =
    DeleteInboundShipmentError
  | DeleteResponse

type DeleteInboundShipmentResponseWithId {
  id: String!
  response: DeleteInboundShipmentResponse!
}

# Generic Error Wrapper
type DeleteOutboundShipmentError {
  error: DeleteOutboundShipmentErrorInterface!
}

interface DeleteOutboundShipmentErrorInterface {
  description: String!
}

# Generic Error Wrapper
type DeleteOutboundShipmentLineError {
  error: DeleteOutboundShipmentLineErrorInterface!
}

interface DeleteOutboundShipmentLineErrorInterface {
  description: String!
}

input DeleteOutboundShipmentLineInput {
  id: String!
  invoiceId: String!
}

union DeleteOutboundShipmentLineResponse =
    DeleteOutboundShipmentLineError
  | DeleteResponse

type DeleteOutboundShipmentLineResponseWithId {
  id: String!
  response: DeleteOutboundShipmentLineResponse!
}

union DeleteOutboundShipmentResponse =
    DeleteOutboundShipmentError
  | DeleteResponse

type DeleteOutboundShipmentResponseWithId {
  id: String!
  response: DeleteOutboundShipmentResponse!
}

type DeleteResponse {
  id: String!
}

input EqualFilterBoolInput {
  equalTo: Boolean
}

input EqualFilterInvoiceStatusInput {
  equalTo: InvoiceNodeStatus
}

input EqualFilterInvoiceTypeInput {
  equalTo: InvoiceNodeType
}

input EqualFilterStringInput {
  # Search term must be an exact match
  equalTo: String
}

type FinalisedInvoiceIsNotEditableError implements UpdateOutboundShipmentErrorInterface {
  description: String!
}

enum ForeignKey {
  OTHER_PARTY_ID
  ITEM_ID
  INVOICE_ID
  STOCK_LINE_ID
}

type ForeignKeyError implements UpdateOutboundShipmentLineErrorInterface & InsertInboundShipmentErrorInterface & UpdateInboundShipmentErrorInterface & InsertInboundShipmentLineErrorInterface & InsertOutboundShipmentLineErrorInterface & DeleteInboundShipmentLineErrorInterface & DeleteOutboundShipmentLineErrorInterface & UpdateOutboundShipmentErrorInterface & UpdateInboundShipmentLineErrorInterface & InsertOutboundShipmentErrorInterface {
  description: String!
  key: ForeignKey!
}

# Generic Error Wrapper
type InsertInboundShipmentError {
  error: InsertInboundShipmentErrorInterface!
}

interface InsertInboundShipmentErrorInterface {
  description: String!
}

input InsertInboundShipmentInput {
  id: String!
  otherPartyId: String!
  status: InvoiceNodeStatus!
  onHold: Boolean
  comment: String
  theirReference: String
}

# Generic Error Wrapper
type InsertInboundShipmentLineError {
  error: InsertInboundShipmentLineErrorInterface!
}

interface InsertInboundShipmentLineErrorInterface {
  description: String!
}

input InsertInboundShipmentLineInput {
  id: String!
  invoiceId: String!
  itemId: String!
  packSize: Int!
  batch: String
  costPricePerPack: Float!
  sellPricePerPack: Float!
  expiryDate: NaiveDate
  numberOfPacks: Int!
}

union InsertInboundShipmentLineResponse =
    InsertInboundShipmentLineError
  | NodeError
  | InvoiceLineNode

type InsertInboundShipmentLineResponseWithId {
  id: String!
  response: InsertInboundShipmentLineResponse!
}

union InsertInboundShipmentResponse =
    InsertInboundShipmentError
  | NodeError
  | InvoiceNode

type InsertInboundShipmentResponseWithId {
  id: String!
  response: InsertInboundShipmentResponse!
}

# Generic Error Wrapper
type InsertOutboundShipmentError {
  error: InsertOutboundShipmentErrorInterface!
}

interface InsertOutboundShipmentErrorInterface {
  description: String!
}

input InsertOutboundShipmentInput {
  # The new invoice id provided by the client
  id: String!

  # The other party must be an customer of the current store
  otherPartyId: String!
  status: InvoiceNodeStatus
  onHold: Boolean
  comment: String
  theirReference: String
}

# Generic Error Wrapper
type InsertOutboundShipmentLineError {
  error: InsertOutboundShipmentLineErrorInterface!
}

interface InsertOutboundShipmentLineErrorInterface {
  description: String!
}

input InsertOutboundShipmentLineInput {
  id: String!
  invoiceId: String!
  itemId: String!
  stockLineId: String!
  numberOfPacks: Int!
}

union InsertOutboundShipmentLineResponse =
    InsertOutboundShipmentLineError
  | NodeError
  | InvoiceLineNode

type InsertOutboundShipmentLineResponseWithId {
  id: String!
  response: InsertOutboundShipmentLineResponse!
}

union InsertOutboundShipmentResponse =
    InsertOutboundShipmentError
  | NodeError
  | InvoiceNode

type InsertOutboundShipmentResponseWithId {
  id: String!
  response: InsertOutboundShipmentResponse!
}

# Generic Connector
type InvoiceConnector {
  totalCount: Int!
  nodes: [InvoiceNode!]!
}

type InvoiceDoesNotBelongToCurrentStore implements DeleteOutboundShipmentErrorInterface & DeleteInboundShipmentLineErrorInterface & UpdateInboundShipmentErrorInterface & DeleteOutboundShipmentLineErrorInterface & UpdateOutboundShipmentLineErrorInterface & DeleteInboundShipmentErrorInterface & UpdateInboundShipmentLineErrorInterface & InsertOutboundShipmentLineErrorInterface & InsertInboundShipmentLineErrorInterface {
  description: String!
}

input InvoiceFilterInput {
  ## Additions
  otherPartyName: SimpleStringFilterInput
  nameId: SimpleStringFilterInput
  storeId: SimpleStringFilterInput
  type: SimpleStringFilterInput
  status: SimpleStringFilterInput
  comment: SimpleStringFilterInput
  theirReference: SimpleStringFilterInput
  entryDatetime: DatetimeFilterInput
  confirmDatetime: DatetimeFilterInput
  finalisedDatetime: DatetimeFilterInput
}

type InvoiceLineBelongsToAnotherInvoice implements DeleteOutboundShipmentLineErrorInterface & UpdateOutboundShipmentLineErrorInterface & DeleteInboundShipmentLineErrorInterface & UpdateInboundShipmentLineErrorInterface {
  description: String!
  invoice: InvoiceResponse!
}

# Generic Connector
type InvoiceLineConnector {
  totalCount: Int!
  nodes: [InvoiceLineNode!]!
}

type InvoiceLineHasNoStockLineError implements UpdateOutboundShipmentErrorInterface {
  description: String!
  invoiceLineId: String!
}

type InvoiceLineNode {
  id: String!
  itemId: String!
  itemName: String!
  itemCode: String!
  packSize: Int!
  numberOfPacks: Int!
  costPricePerPack: Float!
  sellPricePerPack: Float!
  batch: String
  expiryDate: NaiveDate
  stockLine: StockLineResponse

  ## Additions
  location: LocationResponse
  locationDescription: String
  note: String
  itemUnit: String!
}

union InvoiceLineResponse = NodeError | InvoiceLineNode

union InvoiceLinesResponse = ConnectorError | InvoiceLineConnector

type InvoiceNode {
  id: String!
  otherPartyName: String!
  otherPartyId: String!
  type: InvoiceNodeType!
  status: InvoiceNodeStatus!
  invoiceNumber: Int!
  theirReference: String
  comment: String
  onHold: Boolean!
  entryDatetime: DateTime!
  confirmedDatetime: DateTime
  finalisedDatetime: DateTime
  lines: InvoiceLinesResponse!
  pricing: InvoicePriceResponse!

  ## Additions
  otherParty: NameResponse!
  draftDatetime: DateTime
  allocatedDatetime: DateTime
  pickedDatetime: DateTime
  shippedDatetime: DateTime
  deliveredDatetime: DateTime
  color: String!
  enteredByName: String!
  donorName: String!
  purchaseOrderNumber: Int
  requisitionNumber: Int
  goodsReceiptNumber: Int
  inboundShipmentNumber: Int
  shippingMethod: String
  transportReference: String
}

enum InvoiceNodeStatus {
  # For outbound shipments: In DRAFT mode only the available_number_of_packs in a stock line gets
  # updated when items are added to the invoice.
  DRAFT

  # For outbound shipments: When an invoice is CONFIRMED available_number_of_packs and
  # total_number_of_packs get updated when items are added to the invoice.
  CONFIRMED

  # A FINALISED invoice can't be edited nor deleted.
  FINALISED

  ## Additions
  ALLOCATED
  PICKED
  SHIPPED
  DELIVERED
}

enum InvoiceNodeType {
  OUTBOUND_SHIPMENT
  INBOUND_SHIPMENT
}

union InvoicePriceResponse = NodeError | InvoicePricingNode

type InvoicePricingNode {
  totalAfterTax: Float!
  ## Additions
  taxPercentage: Float!
  subtotal: Float!
}

union InvoiceResponse = NodeError | InvoiceNode

enum InvoiceSortFieldInput {
  TYPE
  STATUS
  ENTRY_DATETIME
  CONFIRM_DATETIME
  FINALISED_DATE_TIME
  COMMENT

  ## Additions
  TOTAL_AFTER_TAX
  OTHER_PARTY_NAME
  INVOICE_NUMBER
}

input InvoiceSortInput {
  # Sort query result by `key`
  key: InvoiceSortFieldInput!

  # Sort query result is sorted descending or ascending (if not provided the default is
  # ascending)
  desc: Boolean
}

union InvoicesResponse = ConnectorError | InvoiceConnector

# Generic Connector
type ItemConnector {
  totalCount: Int!
  nodes: [ItemNode!]!
}

type ItemDoesNotMatchStockLine implements InsertOutboundShipmentLineErrorInterface & UpdateOutboundShipmentLineErrorInterface {
  description: String!
}

input ItemFilterInput {
  name: SimpleStringFilterInput
  code: SimpleStringFilterInput
  isVisible: EqualFilterBoolInput
}

type ItemNode {
  id: String!
  name: String!
  code: String!
  isVisible: Boolean!
  availableBatches: StockLinesResponse!

  ## Additions
  unitName: String!
  availableQuantity: Float!
}

enum ItemSortFieldInput {
  NAME
  CODE
}

input ItemSortInput {
  # Sort query result by `key`
  key: ItemSortFieldInput!

  # Sort query result is sorted descending or ascending (if not provided the default is
  # ascending)
  desc: Boolean
}

union ItemsResponse = ConnectorError | ItemConnector

type LineDoesNotReferenceStockLine implements UpdateOutboundShipmentLineErrorInterface {
  description: String!
}

type Mutations {
  insertOutboundShipment(
    input: InsertOutboundShipmentInput!
  ): InsertOutboundShipmentResponse!
  updateOutboundShipment(
    input: UpdateOutboundShipmentInput!
  ): UpdateOutboundShipmentResponse!
  deleteOutboundShipment(id: String!): DeleteOutboundShipmentResponse!
  insertOutboundShipmentLine(
    input: InsertOutboundShipmentLineInput!
  ): InsertOutboundShipmentLineResponse!
  updateOutboundShipmentLine(
    input: UpdateOutboundShipmentLineInput!
  ): UpdateOutboundShipmentLineResponse!
  deleteOutboundShipmentLine(
    input: DeleteOutboundShipmentLineInput!
  ): DeleteOutboundShipmentLineResponse!
  insertInboundShipment(
    input: InsertInboundShipmentInput!
  ): InsertInboundShipmentResponse!
  updateInboundShipment(
    input: UpdateInboundShipmentInput!
  ): UpdateInboundShipmentResponse!
  deleteInboundShipment(
    input: DeleteInboundShipmentInput!
  ): DeleteInboundShipmentResponse!
  insertInboundShipmentLine(
    input: InsertInboundShipmentLineInput!
  ): InsertInboundShipmentLineResponse!
  updateInboundShipmentLine(
    input: UpdateInboundShipmentLineInput!
  ): UpdateInboundShipmentLineResponse!
  deleteInboundShipmentLine(
    input: DeleteInboundShipmentLineInput!
  ): DeleteInboundShipmentLineResponse!
  batchInboundShipment(
    insertInboundShipments: [InsertInboundShipmentInput!]
    insertInboundShipmentLines: [InsertInboundShipmentLineInput!]
    updateInboundShipmentLines: [UpdateInboundShipmentLineInput!]
    deleteInboundShipmentLines: [DeleteInboundShipmentLineInput!]
    updateInboundShipments: [UpdateInboundShipmentInput!]
    deleteInboundShipments: [DeleteInboundShipmentInput!]
  ): BatchInboundShipmentResponse!
  batchOutboundShipment(
    insertOutboundShipments: [InsertOutboundShipmentInput!]
    insertOutboundShipmentLines: [InsertOutboundShipmentLineInput!]
    updateOutboundShipmentLines: [UpdateOutboundShipmentLineInput!]
    deleteOutboundShipmentLines: [DeleteOutboundShipmentLineInput!]
    updateOutboundShipments: [UpdateOutboundShipmentInput!]
    deleteOutboundShipments: [String!]
  ): BatchOutboundShipmentResponse!
}

scalar NaiveDate

# Generic Connector
type NameConnector {
  totalCount: Int!
  nodes: [NameNode!]!
}

input NameFilterInput {
  # Filter by name
  name: SimpleStringFilterInput

  # Filter by code
  code: SimpleStringFilterInput

  # Filter by customer property
  isCustomer: Boolean

  # Filter by supplier property
  isSupplier: Boolean
}

type NameNode {
  id: String!
  name: String!
  code: String!
  isCustomer: Boolean!
  isSupplier: Boolean!
}

enum NameSortFieldInput {
  NAME
  CODE
}

input NameSortInput {
  # Sort query result by `key`
  key: NameSortFieldInput!

  # Sort query result is sorted descending or ascending (if not provided the default is
  # ascending)
  desc: Boolean
}

union NamesResponse = ConnectorError | NameConnector

# Generic Error Wrapper
type NodeError {
  error: NodeErrorInterface!
}

interface NodeErrorInterface {
  description: String!
}

type NotAnInboundShipment implements UpdateInboundShipmentLineErrorInterface & DeleteInboundShipmentErrorInterface & InsertInboundShipmentLineErrorInterface & UpdateInboundShipmentErrorInterface & DeleteInboundShipmentLineErrorInterface {
  description: String!
}

type NotAnOutboundShipment implements InsertOutboundShipmentLineErrorInterface & UpdateOutboundShipmentLineErrorInterface & DeleteOutboundShipmentErrorInterface & DeleteOutboundShipmentLineErrorInterface {
  description: String!
}

type NotAnOutboundShipmentError implements UpdateOutboundShipmentErrorInterface {
  description: String!
}

type NotEnoughStockForReduction implements InsertOutboundShipmentLineErrorInterface & UpdateOutboundShipmentLineErrorInterface {
  description: String!
  line: InvoiceLineResponse
  batch: StockLineResponse!
}

type OtherPartyCannotBeThisStoreError implements InsertOutboundShipmentErrorInterface & UpdateOutboundShipmentErrorInterface {
  description: String!
}

type OtherPartyNotACustomerError implements UpdateOutboundShipmentErrorInterface & InsertOutboundShipmentErrorInterface {
  description: String!
  otherParty: NameNode!
}

type OtherPartyNotASupplier implements UpdateInboundShipmentErrorInterface & InsertInboundShipmentErrorInterface {
  description: String!
  otherParty: NameNode!
}

type PaginationError implements ConnectorErrorInterface {
  description: String!
  rangeError: RangeError!
}

# Pagination input.
#
# Option to limit the number of returned items and/or queries large lists in "pages".
input PaginationInput {
  # Max number of returned items
  first: Int

  # First returned item is at the `offset` position in the full list
  offset: Int
}

type Queries {
  apiVersion: String!

  # Query omSupply "name" entries
  names(
    # Pagination option (first and offset)
    page: PaginationInput

    # Filter option
    filter: NameFilterInput

    # Sort options (only first sort input is evaluated for this endpoint)
    sort: [NameSortInput!]
  ): NamesResponse!

  # Query omSupply "item" entries
  items(
    # Pagination option (first and offset)
    page: PaginationInput

    # Filter option
    filter: ItemFilterInput

    # Sort options (only first sort input is evaluated for this endpoint)
    sort: [ItemSortInput!]
  ): ItemsResponse!
  invoice(
    # id of the invoice
    id: String!
  ): InvoiceResponse!
  invoices(
    # Pagination option (first and offset)
    page: PaginationInput

    # Filter option
    filter: InvoiceFilterInput

    # Sort options (only first sort input is evaluated for this endpoint)
    sort: [InvoiceSortInput!]
  ): InvoicesResponse!
  invoiceCounts(type: InvoiceNodeType!): InvoiceCountsResponse!
  stockCounts: StockCountsResponse!
}

type RangeError implements UpdateInboundShipmentLineErrorInterface & UpdateOutboundShipmentLineErrorInterface & InsertInboundShipmentLineErrorInterface & InsertOutboundShipmentLineErrorInterface {
  description: String!
  field: RangeField!
  max: Int
  min: Int
}

enum RangeField {
  FIRST
  NUMBER_OF_PACKS
  PACK_SIZE
}

type RecordAlreadyExist implements InsertInboundShipmentErrorInterface & InsertOutboundShipmentErrorInterface & InsertOutboundShipmentLineErrorInterface & InsertInboundShipmentLineErrorInterface {
  description: String!
}

type RecordNotFound implements UpdateInboundShipmentLineErrorInterface & DeleteInboundShipmentErrorInterface & UpdateOutboundShipmentErrorInterface & UpdateInboundShipmentErrorInterface & UpdateOutboundShipmentLineErrorInterface & DeleteOutboundShipmentErrorInterface & DeleteOutboundShipmentLineErrorInterface & DeleteInboundShipmentLineErrorInterface & NodeErrorInterface {
  description: String!
}

input SimpleStringFilterInput {
  # Search term must be an exact match (case sensitive)
  equalTo: String

  # Search term must be included in search candidate (case insensitive)
  like: String
}

type StockLineAlreadyExistsInInvoice implements InsertOutboundShipmentLineErrorInterface & UpdateOutboundShipmentLineErrorInterface {
  description: String!
  line: InvoiceLineResponse!
}

# Generic Connector
type StockLineConnector {
  totalCount: Int!
  nodes: [StockLineNode!]!
}

type StockLineDoesNotBelongToCurrentStore implements UpdateOutboundShipmentLineErrorInterface & InsertOutboundShipmentLineErrorInterface {
  description: String!
}

type StockLineNode {
  id: String!
  itemId: String!
  storeId: String!
  batch: String
  packSize: Int!
  costPricePerPack: Float!
  sellPricePerPack: Float!
  availableNumberOfPacks: Int!
  totalNumberOfPacks: Int!
  expiryDate: NaiveDate

  ## Additions
  location: LocationResponse
  locationDescription: String
  onHold: Boolean!
  note: String
}

union StockLineResponse = NodeError | StockLineNode

union StockLinesResponse = ConnectorError | StockLineConnector

# Generic Error Wrapper
type UpdateInboundShipmentError {
  error: UpdateInboundShipmentErrorInterface!
}

interface UpdateInboundShipmentErrorInterface {
  description: String!
}

input UpdateInboundShipmentInput {
  id: String!
  otherPartyId: String
  status: InvoiceNodeStatus
  onHold: Boolean
  comment: String
  theirReference: String
}

# Generic Error Wrapper
type UpdateInboundShipmentLineError {
  error: UpdateInboundShipmentLineErrorInterface!
}

interface UpdateInboundShipmentLineErrorInterface {
  description: String!
}

input UpdateInboundShipmentLineInput {
  id: String!
  invoiceId: String!
  itemId: String
  packSize: Int
  batch: String
  costPricePerPack: Float
  sellPricePerPack: Float
  expiryDate: NaiveDate
  numberOfPacks: Int
}

union UpdateInboundShipmentLineResponse =
    UpdateInboundShipmentLineError
  | NodeError
  | InvoiceLineNode

type UpdateInboundShipmentLineResponseWithId {
  id: String!
  response: UpdateInboundShipmentLineResponse!
}

union UpdateInboundShipmentResponse =
    UpdateInboundShipmentError
  | NodeError
  | InvoiceNode

type UpdateInboundShipmentResponseWithId {
  id: String!
  response: UpdateInboundShipmentResponse!
}

# Generic Error Wrapper
type UpdateOutboundShipmentError {
  error: UpdateOutboundShipmentErrorInterface!
}

interface UpdateOutboundShipmentErrorInterface {
  description: String!
}

input UpdateOutboundShipmentInput {
  # The new invoice id provided by the client
  id: String!

  # The other party must be a customer of the current store.
  # This field can be used to change the other_party of an invoice
  otherPartyId: String

  # When changing the status from DRAFT to CONFIRMED or FINALISED the total_number_of_packs for
  # existing invoice items gets updated.
  status: InvoiceNodeStatus
  onHold: Boolean
  comment: String

  # External invoice reference, e.g. purchase or shipment number
  theirReference: String

  ## Additions
  color: String
}

# Generic Error Wrapper
type UpdateOutboundShipmentLineError {
  error: UpdateOutboundShipmentLineErrorInterface!
}

interface UpdateOutboundShipmentLineErrorInterface {
  description: String!
}

input UpdateOutboundShipmentLineInput {
  id: String!
  invoiceId: String!
  itemId: String
  stockLineId: String
  numberOfPacks: Int
}

union UpdateOutboundShipmentLineResponse =
    UpdateOutboundShipmentLineError
  | NodeError
  | InvoiceLineNode

type UpdateOutboundShipmentLineResponseWithId {
  id: String!
  response: UpdateOutboundShipmentLineResponse!
}

union UpdateOutboundShipmentResponse =
    UpdateOutboundShipmentError
  | NodeError
  | InvoiceNode

type CountError {
  description: String!
}

type InvoiceCountsCreated {
  today: Int!
  thisWeek: Int!
}

type InvoiceCountsConnector {
  created: InvoiceCountsCreated
  toBePicked: Int
}

type StockCountsConnector {
  expired: Int!
  expiringSoon: Int!
}

union InvoiceCountsResponse = InvoiceCountsConnector | ConnectorError
union StockCountsResponse = StockCountsConnector | ConnectorError
type UpdateOutboundShipmentResponseWithId {
  id: String!
  response: UpdateOutboundShipmentResponse!
}

## Additions

type LocationNode {
  code: String!
  description: String!
}

union LocationResponse = LocationNode | NodeError

union NameResponse = NodeError | NameNode

input BatchOutboundShipmentInput {
  insertOutboundShipments: [InsertOutboundShipmentInput!]
  insertOutboundShipmentLines: [InsertOutboundShipmentLineInput!]
  updateOutboundShipmentLines: [UpdateOutboundShipmentLineInput!]
  deleteOutboundShipmentLines: [DeleteOutboundShipmentLineInput!]
  updateOutboundShipments: [UpdateOutboundShipmentInput!]
  deleteOutboundShipments: [String!]
}
