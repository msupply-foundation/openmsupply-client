schema {
  query: Queries
  mutation: Mutations
}

# Directs the executor to query only when the field exists.
directive @ifdef on FIELD

type AccessDenied implements UserErrorInterface & LogoutErrorInterface {
  description: String!
  fullError: String!
}

type AuthToken {
  # Bearer token
  token: String!
}

# Generic Error Wrapper
type AuthTokenError {
  error: AuthTokenErrorInterface!
}

interface AuthTokenErrorInterface {
  description: String!
}

union AuthTokenResponse = AuthTokenError | AuthToken

type BatchInboundShipmentResponse {
  insertInboundShipments: [InsertInboundShipmentResponseWithId!]
  insertInboundShipmentLines: [InsertInboundShipmentLineResponseWithId!]
  updateInboundShipmentLines: [UpdateInboundShipmentLineResponseWithId!]
  deleteInboundShipmentLines: [DeleteInboundShipmentLineResponseWithId!]
  updateInboundShipments: [UpdateInboundShipmentResponseWithId!]
  deleteInboundShipments: [DeleteInboundShipmentResponseWithId!]
}

type BatchIsReserved implements DeleteInboundShipmentLineErrorInterface & UpdateInboundShipmentLineErrorInterface {
  description: String!
}

type BatchOutboundShipmentResponse {
  insertOutboundShipments: [InsertOutboundShipmentResponseWithId!]
  insertOutboundShipmentLines: [InsertOutboundShipmentLineResponseWithId!]
  updateOutboundShipmentLines: [UpdateOutboundShipmentLineResponseWithId!]
  deleteOutboundShipmentLines: [DeleteOutboundShipmentLineResponseWithId!]
  updateOutboundShipments: [UpdateOutboundShipmentResponseWithId!]
  deleteOutboundShipments: [DeleteOutboundShipmentResponseWithId!]
}

type CanOnlyEditInvoicesInLoggedInStoreError implements UpdateOutboundShipmentErrorInterface {
  description: String!
}

type CannotChangeInvoiceBackToDraft implements UpdateInboundShipmentErrorInterface {
  description: String!
}

type CannotChangeStatusBackToDraftError implements UpdateOutboundShipmentErrorInterface {
  description: String!
}

type CannotChangeStatusOfInvoiceOnHold implements UpdateOutboundShipmentErrorInterface & UpdateInboundShipmentErrorInterface {
  description: String!
}

type CannotDeleteInvoiceWithLines implements DeleteInboundShipmentErrorInterface & DeleteOutboundShipmentErrorInterface {
  description: String!
  lines: InvoiceLineConnector!
}

type CannotEditFinalisedInvoice implements UpdateInboundShipmentLineErrorInterface & InsertOutboundShipmentLineErrorInterface & DeleteInboundShipmentErrorInterface & InsertInboundShipmentLineErrorInterface & UpdateInboundShipmentErrorInterface & DeleteOutboundShipmentErrorInterface & UpdateOutboundShipmentLineErrorInterface & DeleteOutboundShipmentLineErrorInterface & DeleteInboundShipmentLineErrorInterface {
  description: String!
}

# Generic Error Wrapper
type ConnectorError {
  error: ConnectorErrorInterface!
}

interface ConnectorErrorInterface {
  description: String!
}

type DatabaseError implements UpdateOutboundShipmentErrorInterface & DeleteInboundShipmentErrorInterface & RefreshTokenErrorInterface & UpdateInboundShipmentErrorInterface & DeleteInboundShipmentLineErrorInterface & InsertOutboundShipmentErrorInterface & NodeErrorInterface & InsertInboundShipmentLineErrorInterface & UpdateOutboundShipmentLineErrorInterface & AuthTokenErrorInterface & InsertOutboundShipmentLineErrorInterface & ConnectorErrorInterface & DeleteOutboundShipmentLineErrorInterface & UserRegisterErrorInterface & UserErrorInterface & DeleteOutboundShipmentErrorInterface & InsertInboundShipmentErrorInterface & UpdateInboundShipmentLineErrorInterface {
  description: String!
  fullError: String!
}

# Implement the DateTime<Utc> scalar
#
# The input/output is a string in RFC3339 format.
scalar DateTime

input DatetimeFilterInput {
  equalTo: DateTime
  beforeOrEqualTo: DateTime
  afterOrEqualTo: DateTime
}

# Generic Error Wrapper
type DeleteInboundShipmentError {
  error: DeleteInboundShipmentErrorInterface!
}

interface DeleteInboundShipmentErrorInterface {
  description: String!
}

input DeleteInboundShipmentInput {
  id: String!
}

# Generic Error Wrapper
type DeleteInboundShipmentLineError {
  error: DeleteInboundShipmentLineErrorInterface!
}

interface DeleteInboundShipmentLineErrorInterface {
  description: String!
}

input DeleteInboundShipmentLineInput {
  id: String!
  invoiceId: String!
}

union DeleteInboundShipmentLineResponse =
    DeleteInboundShipmentLineError
  | DeleteResponse

type DeleteInboundShipmentLineResponseWithId {
  id: String!
  response: DeleteInboundShipmentLineResponse!
}

union DeleteInboundShipmentResponse =
    DeleteInboundShipmentError
  | DeleteResponse

type DeleteInboundShipmentResponseWithId {
  id: String!
  response: DeleteInboundShipmentResponse!
}

# Generic Error Wrapper
type DeleteOutboundShipmentError {
  error: DeleteOutboundShipmentErrorInterface!
}

interface DeleteOutboundShipmentErrorInterface {
  description: String!
}

# Generic Error Wrapper
type DeleteOutboundShipmentLineError {
  error: DeleteOutboundShipmentLineErrorInterface!
}

interface DeleteOutboundShipmentLineErrorInterface {
  description: String!
}

input DeleteOutboundShipmentLineInput {
  id: String!
  invoiceId: String!
}

union DeleteOutboundShipmentLineResponse =
    DeleteOutboundShipmentLineError
  | DeleteResponse

type DeleteOutboundShipmentLineResponseWithId {
  id: String!
  response: DeleteOutboundShipmentLineResponse!
}

union DeleteOutboundShipmentResponse =
    DeleteOutboundShipmentError
  | DeleteResponse

type DeleteOutboundShipmentResponseWithId {
  id: String!
  response: DeleteOutboundShipmentResponse!
}

type DeleteResponse {
  id: String!
}

input EqualFilterBooleanInput {
  equalTo: Boolean
}

input EqualFilterInvoiceStatusInput {
  equalTo: InvoiceNodeStatus
}

input EqualFilterInvoiceTypeInput {
  equalTo: InvoiceNodeType
}

input EqualFilterNumberInput {
  equalTo: Int
}

input EqualFilterStringInput {
  equalTo: String
}

type FinalisedInvoiceIsNotEditableError implements UpdateOutboundShipmentErrorInterface {
  description: String!
}

enum ForeignKey {
  otherPartyId
  itemId
  invoiceId
  stockLineId
  locationId
}

type ForeignKeyError implements UpdateOutboundShipmentLineErrorInterface & UpdateInboundShipmentLineErrorInterface & UpdateOutboundShipmentErrorInterface & UpdateInboundShipmentErrorInterface & InsertOutboundShipmentErrorInterface & InsertInboundShipmentLineErrorInterface & DeleteInboundShipmentLineErrorInterface & InsertInboundShipmentErrorInterface & DeleteOutboundShipmentLineErrorInterface & InsertOutboundShipmentLineErrorInterface {
  description: String!
  key: ForeignKey!
}

# Generic Error Wrapper
type InsertInboundShipmentError {
  error: InsertInboundShipmentErrorInterface!
}

interface InsertInboundShipmentErrorInterface {
  description: String!
}

input InsertInboundShipmentInput {
  id: String!
  otherPartyId: String!
  status: InvoiceNodeStatus!
  onHold: Boolean
  comment: String
  theirReference: String
  color: String
}

# Generic Error Wrapper
type InsertInboundShipmentLineError {
  error: InsertInboundShipmentLineErrorInterface!
}

interface InsertInboundShipmentLineErrorInterface {
  description: String!
}

input InsertInboundShipmentLineInput {
  id: String!
  invoiceId: String!
  itemId: String!
  packSize: Int!
  batch: String
  locationId: String
  costPricePerPack: Float!
  sellPricePerPack: Float!
  expiryDate: NaiveDate
  numberOfPacks: Int!
}

union InsertInboundShipmentLineResponse =
    InsertInboundShipmentLineError
  | NodeError
  | InvoiceLineNode

type InsertInboundShipmentLineResponseWithId {
  id: String!
  response: InsertInboundShipmentLineResponse!
}

union InsertInboundShipmentResponse =
    InsertInboundShipmentError
  | NodeError
  | InvoiceNode

type InsertInboundShipmentResponseWithId {
  id: String!
  response: InsertInboundShipmentResponse!
}

# Generic Error Wrapper
type InsertOutboundShipmentError {
  error: InsertOutboundShipmentErrorInterface!
}

interface InsertOutboundShipmentErrorInterface {
  description: String!
}

input InsertOutboundShipmentInput {
  # The new invoice id provided by the client
  id: String!

  # The other party must be an customer of the current store
  otherPartyId: String!
  status: InvoiceNodeStatus
  onHold: Boolean
  comment: String
  theirReference: String
  color: String
}

# Generic Error Wrapper
type InsertOutboundShipmentLineError {
  error: InsertOutboundShipmentLineErrorInterface!
}

interface InsertOutboundShipmentLineErrorInterface {
  description: String!
}

input InsertOutboundShipmentLineInput {
  id: String!
  invoiceId: String!
  itemId: String!
  stockLineId: String!
  numberOfPacks: Int!
}

union InsertOutboundShipmentLineResponse =
    InsertOutboundShipmentLineError
  | NodeError
  | InvoiceLineNode

type InsertOutboundShipmentLineResponseWithId {
  id: String!
  response: InsertOutboundShipmentLineResponse!
}

union InsertOutboundShipmentResponse =
    InsertOutboundShipmentError
  | NodeError
  | InvoiceNode

type InsertOutboundShipmentResponseWithId {
  id: String!
  response: InsertOutboundShipmentResponse!
}

type InternalError implements UserRegisterErrorInterface & AuthTokenErrorInterface & RefreshTokenErrorInterface & LogoutErrorInterface & UserErrorInterface {
  description: String!
  fullError: String!
}

type InvalidCredentials implements AuthTokenErrorInterface {
  description: String!
}

type InvalidToken implements RefreshTokenErrorInterface {
  description: String!
}

# Generic Connector
type InvoiceConnector {
  totalCount: Int!
  nodes: [InvoiceNode!]!
}

type InvoiceDoesNotBelongToCurrentStore implements DeleteOutboundShipmentLineErrorInterface & DeleteInboundShipmentErrorInterface & DeleteOutboundShipmentErrorInterface & InsertOutboundShipmentLineErrorInterface & DeleteInboundShipmentLineErrorInterface & UpdateOutboundShipmentLineErrorInterface & UpdateInboundShipmentErrorInterface & InsertInboundShipmentLineErrorInterface & UpdateInboundShipmentLineErrorInterface {
  description: String!
}

input InvoiceFilterInput {
  invoiceNumber: EqualFilterNumberInput
  nameId: EqualFilterStringInput
  storeId: EqualFilterStringInput
  type: EqualFilterInvoiceTypeInput
  status: EqualFilterInvoiceStatusInput
  comment: SimpleStringFilterInput
  theirReference: EqualFilterStringInput
  entryDatetime: DatetimeFilterInput
  confirmDatetime: DatetimeFilterInput
  finalisedDatetime: DatetimeFilterInput
}

type InvoiceLineBelongsToAnotherInvoice implements UpdateOutboundShipmentLineErrorInterface & DeleteInboundShipmentLineErrorInterface & UpdateInboundShipmentLineErrorInterface & DeleteOutboundShipmentLineErrorInterface {
  description: String!
  invoice: InvoiceResponse!
}

# Generic Connector
type InvoiceLineConnector {
  totalCount: Int!
  nodes: [InvoiceLineNode!]!
}

type InvoiceLineHasNoStockLineError implements UpdateOutboundShipmentErrorInterface {
  description: String!
  invoiceLineId: String!
}

type InvoiceLineNode {
  id: String!
  itemId: String!
  itemName: String!
  itemCode: String!
  packSize: Int!
  numberOfPacks: Int!
  costPricePerPack: Float!
  sellPricePerPack: Float!
  batch: String
  expiryDate: NaiveDate
  note: String
  locationName: String
  locationId: String
  location: LocationResponse
  stockLine: StockLineResponse
}

union InvoiceLineResponse = NodeError | InvoiceLineNode

union InvoiceLinesResponse = ConnectorError | InvoiceLineConnector

type InvoiceNode {
  id: String!
  otherPartyName: String!
  otherPartyId: String!
  type: InvoiceNodeType!
  status: InvoiceNodeStatus!
  invoiceNumber: Int!
  theirReference: String
  comment: String
  onHold: Boolean!
  entryDatetime: DateTime!
  confirmedDatetime: DateTime
  finalisedDatetime: DateTime
  color: String
  lines: InvoiceLinesResponse!
  pricing: InvoicePriceResponse!
  otherParty: NameResponse!
}

enum InvoiceNodeStatus {
  # For outbound shipments: In DRAFT mode only the available_number_of_packs in a stock line gets
  # updated when items are added to the invoice.
  DRAFT

  # For outbound shipments: When an invoice is CONFIRMED available_number_of_packs and
  # total_number_of_packs get updated when items are added to the invoice.
  CONFIRMED

  # A FINALISED invoice can't be edited nor deleted.
  FINALISED
}

enum InvoiceNodeType {
  OUTBOUND_SHIPMENT
  INBOUND_SHIPMENT
}

union InvoicePriceResponse = NodeError | InvoicePricingNode

type InvoicePricingNode {
  totalAfterTax: Float!
}

union InvoiceResponse = NodeError | InvoiceNode

enum InvoiceSortFieldInput {
  type
  otherPartyName
  invoiceNumber
  comment
  status
  entryDatetime
  confirmDatetime
  finalisedDateTime
}

input InvoiceSortInput {
  # Sort query result by `key`
  key: InvoiceSortFieldInput!

  # Sort query result is sorted descending or ascending (if not provided the default is
  # ascending)
  desc: Boolean
}

union InvoicesResponse = ConnectorError | InvoiceConnector

# Generic Connector
type ItemConnector {
  totalCount: Int!
  nodes: [ItemNode!]!
}

type ItemDoesNotMatchStockLine implements InsertOutboundShipmentLineErrorInterface & UpdateOutboundShipmentLineErrorInterface {
  description: String!
}

input ItemFilterInput {
  name: SimpleStringFilterInput
  code: SimpleStringFilterInput
  isVisible: EqualFilterBooleanInput
}

type ItemNode {
  id: String!
  name: String!
  code: String!
  isVisible: Boolean!
  unitName: String
  availableBatches: StockLinesResponse!
}

enum ItemSortFieldInput {
  name
  code
}

input ItemSortInput {
  # Sort query result by `key`
  key: ItemSortFieldInput!

  # Sort query result is sorted descending or ascending (if not provided the default is
  # ascending)
  desc: Boolean
}

union ItemsResponse = ConnectorError | ItemConnector

type LineDoesNotReferenceStockLine implements UpdateOutboundShipmentLineErrorInterface {
  description: String!
}

# Generic Connector
type LocationConnector {
  totalCount: Int!
  nodes: [LocationNode!]!
}

input LocationFilterInput {
  name: EqualFilterStringInput
  code: EqualFilterStringInput
  id: EqualFilterStringInput
}

type LocationIsOnHold implements InsertOutboundShipmentLineErrorInterface & UpdateOutboundShipmentLineErrorInterface {
  description: String!
}

type LocationNode {
  id: String!
  name: String!
  code: String!
  onHold: Boolean!
  stock: StockLinesResponse!
}

type LocationNotFound implements InsertOutboundShipmentLineErrorInterface & UpdateOutboundShipmentLineErrorInterface {
  description: String!
}

union LocationResponse = NodeError | LocationNode

enum LocationSortFieldInput {
  name
  code
}

input LocationSortInput {
  # Sort query result by `key`
  key: LocationSortFieldInput!

  # Sort query result is sorted descending or ascending (if not provided the default is
  # ascending)
  desc: Boolean
}

union LocationsResponse = ConnectorError | LocationConnector

type Logout {
  # User id of the logged out user
  userId: String!
}

# Generic Error Wrapper
type LogoutError {
  error: LogoutErrorInterface!
}

interface LogoutErrorInterface {
  description: String!
}

union LogoutResponse = LogoutError | Logout

type Mutations {
  registerUser(input: UserRegisterInput!): UserRegisterResponse!
  insertOutboundShipment(
    input: InsertOutboundShipmentInput!
  ): InsertOutboundShipmentResponse!
  updateOutboundShipment(
    input: UpdateOutboundShipmentInput!
  ): UpdateOutboundShipmentResponse!
  deleteOutboundShipment(id: String!): DeleteOutboundShipmentResponse!
  insertOutboundShipmentLine(
    input: InsertOutboundShipmentLineInput!
  ): InsertOutboundShipmentLineResponse!
  updateOutboundShipmentLine(
    input: UpdateOutboundShipmentLineInput!
  ): UpdateOutboundShipmentLineResponse!
  deleteOutboundShipmentLine(
    input: DeleteOutboundShipmentLineInput!
  ): DeleteOutboundShipmentLineResponse!
  insertInboundShipment(
    input: InsertInboundShipmentInput!
  ): InsertInboundShipmentResponse!
  updateInboundShipment(
    input: UpdateInboundShipmentInput!
  ): UpdateInboundShipmentResponse!
  deleteInboundShipment(
    input: DeleteInboundShipmentInput!
  ): DeleteInboundShipmentResponse!
  insertInboundShipmentLine(
    input: InsertInboundShipmentLineInput!
  ): InsertInboundShipmentLineResponse!
  updateInboundShipmentLine(
    input: UpdateInboundShipmentLineInput!
  ): UpdateInboundShipmentLineResponse!
  deleteInboundShipmentLine(
    input: DeleteInboundShipmentLineInput!
  ): DeleteInboundShipmentLineResponse!
  batchInboundShipment(
    insertInboundShipments: [InsertInboundShipmentInput!]
    insertInboundShipmentLines: [InsertInboundShipmentLineInput!]
    updateInboundShipmentLines: [UpdateInboundShipmentLineInput!]
    deleteInboundShipmentLines: [DeleteInboundShipmentLineInput!]
    updateInboundShipments: [UpdateInboundShipmentInput!]
    deleteInboundShipments: [DeleteInboundShipmentInput!]
  ): BatchInboundShipmentResponse!
  batchOutboundShipment(
    insertOutboundShipments: [InsertOutboundShipmentInput!]
    insertOutboundShipmentLines: [InsertOutboundShipmentLineInput!]
    updateOutboundShipmentLines: [UpdateOutboundShipmentLineInput!]
    deleteOutboundShipmentLines: [DeleteOutboundShipmentLineInput!]
    updateOutboundShipments: [UpdateOutboundShipmentInput!]
    deleteOutboundShipments: [String!]
  ): BatchOutboundShipmentResponse!

  updateSupplierRequisition(
    input: UpdateSupplierRequisitionInput!
  ): UpdateSupplierRequisitionResponse!
  insertSupplierRequisition(
    input: InsertSupplierRequisitionInput!
  ): InsertSupplierRequisitionResponse!
  deleteSupplierRequisition(
    input: DeleteSupplierRequisitionInput!
  ): DeleteSupplierRequisitionResponse!
  updateSupplierRequisitionLine(
    input: UpdateSupplierRequisitionLineInput!
  ): UpdateSupplierRequisitionLineResponse!
  insertSupplierRequisitionLine(
    input: InsertSupplierRequisitionLineInput!
  ): InsertSupplierRequisitionLineResponse!
  deleteSupplierRequisitionLine(
    input: DeleteSupplierRequisitionLineInput!
  ): DeleteSupplierRequisitionLineResponse!
  batchSupplierRequisition(
    insertSupplierRequisitions: [InsertSupplierRequisitionInput!]
    updateSupplierRequisitions: [UpdateSupplierRequisitionInput!]
    deleteSupplierRequisitions: [DeleteSupplierRequisitionInput!]
    insertSupplierRequisitionLines: [InsertSupplierRequisitionLineInput!]
    updateSupplierRequisitionLines: [UpdateSupplierRequisitionLineInput!]
    deleteSupplierRequisitionLines: [DeleteSupplierRequisitionLineInput!]
  ): BatchSupplierRequisitionResponse!

  updateCustomerRequisition(
    input: UpdateCustomerRequisitionInput!
  ): UpdateCustomerRequisitionResponse!
  insertCustomerRequisition(
    input: InsertCustomerRequisitionInput!
  ): InsertCustomerRequisitionResponse!
  deleteCustomerRequisition(
    input: DeleteCustomerRequisitionInput!
  ): DeleteCustomerRequisitionResponse!
  updateCustomerRequisitionLine(
    input: UpdateCustomerRequisitionLineInput!
  ): UpdateCustomerRequisitionLineResponse!
  insertCustomerRequisitionLine(
    input: InsertCustomerRequisitionLineInput!
  ): InsertCustomerRequisitionLineResponse!
  deleteCustomerRequisitionLine(
    input: DeleteCustomerRequisitionLineInput!
  ): DeleteCustomerRequisitionLineResponse!
  batchCustomerRequisition(
    insertCustomerRequisitions: [InsertCustomerRequisitionInput!]
    updateCustomerRequisitions: [UpdateCustomerRequisitionInput!]
    deleteCustomerRequisitions: [DeleteCustomerRequisitionInput!]
    insertCustomerRequisitionLines: [InsertCustomerRequisitionLineInput!]
    updateCustomerRequisitionLines: [UpdateCustomerRequisitionLineInput!]
    deleteCustomerRequisitionLines: [DeleteCustomerRequisitionLineInput!]
  ): BatchCustomerRequisitionResponse!

  updateStocktake(input: UpdateStocktakeInput!): UpdateStocktakeResponse!
  insertStocktake(input: InsertStocktakeInput!): InsertStocktakeResponse!
  deleteStocktake(input: DeleteStocktakeInput!): DeleteStocktakeResponse!
  batchStocktake(
    insertStocktakes: [InsertStocktakeInput!]
    updateStocktakes: [UpdateStocktakeInput!]
    deleteStocktakes: [DeleteStocktakeInput!]
    insertStocktakeLines: [InsertStocktakeLineInput!]
    updateStocktakeLines: [UpdateStocktakeLineInput!]
    deleteStocktakeLines: [DeleteStocktakeLineInput!]
  ): BatchStocktakeResponse!
}

# ISO 8601 calendar date without timezone.
# Format: %Y-%m-%d
#
# # Examples
#
# * `1994-11-13`
# * `2000-02-24`
scalar NaiveDate

# Generic Connector
type NameConnector {
  totalCount: Int!
  nodes: [NameNode!]!
}

input NameFilterInput {
  # Filter by name
  name: SimpleStringFilterInput

  # Filter by code
  code: SimpleStringFilterInput

  # Filter by customer property
  isCustomer: Boolean

  # Filter by supplier property
  isSupplier: Boolean
}

type NameNode {
  id: String!
  name: String!
  code: String!
  isCustomer: Boolean!
  isSupplier: Boolean!
}

union NameResponse = NodeError | NameNode

enum NameSortFieldInput {
  name
  code
}

input NameSortInput {
  # Sort query result by `key`
  key: NameSortFieldInput!

  # Sort query result is sorted descending or ascending (if not provided the default is
  # ascending)
  desc: Boolean
}

union NamesResponse = ConnectorError | NameConnector

type NoRefreshTokenProvided implements RefreshTokenErrorInterface {
  description: String!
}

# Generic Error Wrapper
type NodeError {
  error: NodeErrorInterface!
}

interface NodeErrorInterface {
  description: String!
}

type NotARefreshToken implements RefreshTokenErrorInterface {
  description: String!
}

type NotAnInboundShipment implements UpdateInboundShipmentErrorInterface & DeleteInboundShipmentErrorInterface & InsertInboundShipmentLineErrorInterface & UpdateInboundShipmentLineErrorInterface & DeleteInboundShipmentLineErrorInterface {
  description: String!
}

type NotAnOutboundShipment implements UpdateOutboundShipmentLineErrorInterface & DeleteOutboundShipmentErrorInterface & InsertOutboundShipmentLineErrorInterface & DeleteOutboundShipmentLineErrorInterface {
  description: String!
}

type NotAnOutboundShipmentError implements UpdateOutboundShipmentErrorInterface {
  description: String!
}

type NotEnoughStockForReduction implements InsertOutboundShipmentLineErrorInterface & UpdateOutboundShipmentLineErrorInterface {
  description: String!
  line: InvoiceLineResponse
  batch: StockLineResponse!
}

type OtherPartyCannotBeThisStoreError implements InsertOutboundShipmentErrorInterface & UpdateOutboundShipmentErrorInterface {
  description: String!
}

type OtherPartyNotACustomerError implements UpdateOutboundShipmentErrorInterface & InsertOutboundShipmentErrorInterface {
  description: String!
  otherParty: NameNode!
}

type OtherPartyNotASupplier implements InsertInboundShipmentErrorInterface & UpdateInboundShipmentErrorInterface {
  description: String!
  otherParty: NameNode!
}

type PaginationError implements ConnectorErrorInterface {
  description: String!
  rangeError: RangeError!
}

# Pagination input.
#
# Option to limit the number of returned items and/or queries large lists in "pages".
input PaginationInput {
  # Max number of returned items
  first: Int

  # First returned item is at the `offset` position in the full list
  offset: Int
}

type Queries {
  apiVersion: String!

  # Retrieves a new auth bearer and refresh token
  # The refresh token is returned as a cookie
  authToken(
    # UserName
    username: String!

    # Password
    password: String!
  ): AuthTokenResponse!
  logout: LogoutResponse!

  # Retrieves a new auth bearer and refresh token
  # The refresh token is returned as a cookie
  refreshToken: RefreshTokenResponse!
  me: UserResponse!

  # Query omSupply "name" entries
  names(
    # Pagination option (first and offset)
    page: PaginationInput

    # Filter option
    filter: NameFilterInput

    # Sort options (only first sort input is evaluated for this endpoint)
    sort: [NameSortInput!]
  ): NamesResponse!

  # Query omSupply "item" entries
  locations(
    # Pagination option (first and offset)
    page: PaginationInput

    # Filter option
    filter: LocationFilterInput

    # Sort options (only first sort input is evaluated for this endpoint)
    sort: [LocationSortInput!]
  ): LocationsResponse!

  # Query omSupply "item" entries
  items(
    # Pagination option (first and offset)
    page: PaginationInput

    # Filter option
    filter: ItemFilterInput

    # Sort options (only first sort input is evaluated for this endpoint)
    sort: [ItemSortInput!]
  ): ItemsResponse!
  invoice(
    # id of the invoice
    id: String!
  ): InvoiceResponse!
  invoices(
    # Pagination option (first and offset)
    page: PaginationInput

    # Filter option
    filter: InvoiceFilterInput

    # Sort options (only first sort input is evaluated for this endpoint)
    sort: [InvoiceSortInput!]
  ): InvoicesResponse!

  ## Additions
  invoiceCounts(type: InvoiceNodeType!): InvoiceCountsResponse!
  stockCounts: StockCountsResponse!

  requisition(
    # id of the invoice
    id: String!
  ): RequisitionResponse!

  requisitions(params: RequisitionListParameters): RequisitionsResponse!

  stocktake(
    # id of the invoice
    id: String!
  ): StocktakeResponse!

  stocktakes(params: StocktakeListParameters): StocktakesResponse!
}

input StocktakeListParameters {
  page: PaginationInput
  filter: StocktakeFilterInput
  sort: [StocktakeSortInput!]
}

input StocktakeFilterInput {
  description: SimpleStringFilterInput
}

enum StocktakeSortFieldInput {
  description
}

input StocktakeSortInput {
  # Sort query result by `key`
  key: StocktakeSortFieldInput!

  # Sort query result is sorted descending or ascending (if not provided the default is
  # ascending)
  desc: Boolean
}

input RequisitionListParameters {
  page: PaginationInput
  filter: RequisitionFilterInput
  sort: [RequisitionSortInput!]
}

input RequisitionFilterInput {
  type: SimpleStringFilterInput
  comment: SimpleStringFilterInput
}

enum RequisitionSortFieldInput {
  otherPartyName
}

input RequisitionSortInput {
  key: RequisitionSortFieldInput!
  desc: Boolean
}

type RangeError implements UpdateInboundShipmentLineErrorInterface & UpdateOutboundShipmentLineErrorInterface & InsertOutboundShipmentLineErrorInterface & InsertInboundShipmentLineErrorInterface {
  description: String!
  field: RangeField!
  max: Int
  min: Int
}

enum RangeField {
  first
  numberOfPacks
  packSize
}

type RecordAlreadyExist implements InsertInboundShipmentErrorInterface & InsertInboundShipmentLineErrorInterface & InsertOutboundShipmentLineErrorInterface & InsertOutboundShipmentErrorInterface & UserRegisterErrorInterface {
  description: String!
}

type RecordNotFound implements DeleteInboundShipmentLineErrorInterface & DeleteOutboundShipmentLineErrorInterface & NodeErrorInterface & UpdateOutboundShipmentLineErrorInterface & UpdateOutboundShipmentErrorInterface & UpdateInboundShipmentLineErrorInterface & DeleteOutboundShipmentErrorInterface & UpdateInboundShipmentErrorInterface & DeleteInboundShipmentErrorInterface {
  description: String!
}

type RefreshToken {
  # New Bearer token
  token: String!
}

# Generic Error Wrapper
type RefreshTokenError {
  error: RefreshTokenErrorInterface!
}

interface RefreshTokenErrorInterface {
  description: String!
}

union RefreshTokenResponse = RefreshTokenError | RefreshToken

type RegisteredUser {
  id: String!
  username: String!
  email: String
}

input SimpleStringFilterInput {
  # Search term must be an exact match (case sensitive)
  equalTo: String

  # Search term must be included in search candidate (case insensitive)
  like: String
}

type StockLineAlreadyExistsInInvoice implements UpdateOutboundShipmentLineErrorInterface & InsertOutboundShipmentLineErrorInterface {
  description: String!
  line: InvoiceLineResponse!
}

# Generic Connector
type StockLineConnector {
  totalCount: Int!
  nodes: [StockLineNode!]!
}

type StockLineDoesNotBelongToCurrentStore implements InsertOutboundShipmentLineErrorInterface & UpdateOutboundShipmentLineErrorInterface {
  description: String!
}

type StockLineIsOnHold implements InsertOutboundShipmentLineErrorInterface & UpdateOutboundShipmentLineErrorInterface {
  description: String!
}

type StockLineNode {
  id: String!
  itemId: String!
  storeId: String!
  batch: String
  packSize: Int!
  costPricePerPack: Float!
  sellPricePerPack: Float!
  availableNumberOfPacks: Int!
  totalNumberOfPacks: Int!
  expiryDate: NaiveDate
  onHold: Boolean!
  note: String
  locationId: String
  locationName: String
  location: LocationResponse
}

union StockLineResponse = NodeError | StockLineNode

union StockLinesResponse = ConnectorError | StockLineConnector

type TokenExpired implements RefreshTokenErrorInterface {
  description: String!
}

# Generic Error Wrapper
type UpdateInboundShipmentError {
  error: UpdateInboundShipmentErrorInterface!
}

interface UpdateInboundShipmentErrorInterface {
  description: String!
}

input UpdateInboundShipmentInput {
  id: String!
  otherPartyId: String
  status: InvoiceNodeStatus
  onHold: Boolean
  comment: String
  theirReference: String
  color: String
}

# Generic Error Wrapper
type UpdateInboundShipmentLineError {
  error: UpdateInboundShipmentLineErrorInterface!
}

interface UpdateInboundShipmentLineErrorInterface {
  description: String!
}

input UpdateInboundShipmentLineInput {
  id: String!
  invoiceId: String!
  itemId: String
  locationId: String
  packSize: Int
  batch: String
  costPricePerPack: Float
  sellPricePerPack: Float
  expiryDate: NaiveDate
  numberOfPacks: Int
}

union UpdateInboundShipmentLineResponse =
    UpdateInboundShipmentLineError
  | NodeError
  | InvoiceLineNode

type UpdateInboundShipmentLineResponseWithId {
  id: String!
  response: UpdateInboundShipmentLineResponse!
}

union UpdateInboundShipmentResponse =
    UpdateInboundShipmentError
  | NodeError
  | InvoiceNode

type UpdateInboundShipmentResponseWithId {
  id: String!
  response: UpdateInboundShipmentResponse!
}

# Generic Error Wrapper
type UpdateOutboundShipmentError {
  error: UpdateOutboundShipmentErrorInterface!
}

interface UpdateOutboundShipmentErrorInterface {
  description: String!
}

input UpdateOutboundShipmentInput {
  # The new invoice id provided by the client
  id: String!

  # The other party must be a customer of the current store.
  # This field can be used to change the other_party of an invoice
  otherPartyId: String

  # When changing the status from DRAFT to CONFIRMED or FINALISED the total_number_of_packs for
  # existing invoice items gets updated.
  status: InvoiceNodeStatus
  onHold: Boolean
  comment: String

  # External invoice reference, e.g. purchase or shipment number
  theirReference: String
  color: String
}

# Generic Error Wrapper
type UpdateOutboundShipmentLineError {
  error: UpdateOutboundShipmentLineErrorInterface!
}

interface UpdateOutboundShipmentLineErrorInterface {
  description: String!
}

input UpdateOutboundShipmentLineInput {
  id: String!
  invoiceId: String!
  itemId: String
  stockLineId: String
  numberOfPacks: Int
}

union UpdateOutboundShipmentLineResponse =
    UpdateOutboundShipmentLineError
  | NodeError
  | InvoiceLineNode

type UpdateOutboundShipmentLineResponseWithId {
  id: String!
  response: UpdateOutboundShipmentLineResponse!
}

union UpdateOutboundShipmentResponse =
    UpdateOutboundShipmentError
  | NodeError
  | InvoiceNode

type UpdateOutboundShipmentResponseWithId {
  id: String!
  response: UpdateOutboundShipmentResponse!
}

type User {
  # Internal user id
  userId: String!

  # The user's email address
  email: String
}

# Generic Error Wrapper
type UserError {
  error: UserErrorInterface!
}

interface UserErrorInterface {
  description: String!
}

type UserNameDoesNotExist implements AuthTokenErrorInterface {
  description: String!
}

# Generic Error Wrapper
type UserRegisterError {
  error: UserRegisterErrorInterface!
}

interface UserRegisterErrorInterface {
  description: String!
}

input UserRegisterInput {
  username: String!
  password: String!
  email: String
}

union UserRegisterResponse = UserRegisterError | RegisteredUser

union UserResponse = UserError | User

input BatchOutboundShipmentInput {
  insertOutboundShipments: [InsertOutboundShipmentInput!]
  insertOutboundShipmentLines: [InsertOutboundShipmentLineInput!]
  updateOutboundShipmentLines: [UpdateOutboundShipmentLineInput!]
  deleteOutboundShipmentLines: [DeleteOutboundShipmentLineInput!]
  updateOutboundShipments: [UpdateOutboundShipmentInput!]
  deleteOutboundShipments: [String!]
}

input BatchInboundShipmentInput {
  insertOutboundShipments: [InsertInboundShipmentInput!]
  insertInboundShipmentLines: [InsertInboundShipmentLineInput!]
  updateInboundShipmentLines: [UpdateInboundShipmentLineInput!]
  deleteInboundShipmentLines: [DeleteInboundShipmentLineInput!]
  updateInboundShipments: [UpdateInboundShipmentInput!]
  deleteInboundShipments: [DeleteInboundShipmentInput!]
}

type CountError {
  description: String!
}

type InvoiceCountsCreated {
  today: Int!
  thisWeek: Int!
}

type InvoiceCountsConnector {
  created: InvoiceCountsCreated
  toBePicked: Int
}

type StockCountsConnector {
  expired: Int!
  expiringSoon: Int!
}

union InvoiceCountsResponse = InvoiceCountsConnector | ConnectorError
union StockCountsResponse = StockCountsConnector | ConnectorError
type UpdateOutboundShipmentResponseWithId {
  id: String!
  response: UpdateOutboundShipmentResponse!
}

type RequisitionNode {
  id: String!

  color: String
  orderDate: String
  comment: String
  theirReference: String
  type: RequisitionNodeType
  requisitionNumber: Int!
  thresholdMOS: Int
  maxMOS: Int
  status: SupplierRequisitionNodeStatus!
  lines: RequisitionLinesResponse!

  otherParty: NameResponse!
  otherPartyId: String!
  otherPartyName: String!
}

type StocktakeNode {
  id: String!
  stocktakeNumber: Int!
  stocktakeDate: String
  comment: String
  description: String
  status: StocktakeNodeStatus!
  lines: StocktakeLinesResponse!
}

type StocktakeLineNode {
  id: String!
  itemId: String!
  itemName: String!
  itemCode: String!
  batch: String
  expiryDate: NaiveDate
  snapshotNumPacks: Int
  snapshotPackSize: Int
  countedNumPacks: Int
  sellPricePerPack: Float
  costPricePerPack: Float
}

input UpdateStocktakeLineInput {
  id: String!
  batch: String
  expiryDate: NaiveDate
  countedNumPacks: Int
  sellPricePerPack: Float
  costPricePerPack: Float
}

union UpdateStocktakeLineResponse = NodeError | StocktakeLineNode
type UpdateStocktakeLineResponseWithId {
  id: String!
  response: UpdateStocktakeLineResponse
}

input InsertStocktakeLineInput {
  id: String!
  batch: String
  expiryDate: NaiveDate
  countedNumPacks: Int
  sellPricePerPack: Float
  costPricePerPack: Float
  stocktakeId: String!
  itemId: String!
}
union InsertStocktakeLineResponse = NodeError | StocktakeLineNode
type InsertStocktakeLineResponseWithId {
  id: String!
  response: InsertStocktakeLineResponse
}

input DeleteStocktakeLineInput {
  id: String!
}
union DeleteStocktakeLineResponse = NodeError | DeleteResponse
type DeleteStocktakeLineResponseWithId {
  id: String!
  response: DeleteResponse
}

enum StocktakeNodeStatus {
  DRAFT
  CONFIRMED
  FINALISED
}

type RequisitionLineNode {
  id: String!
  itemId: String!
  itemName: String
  itemCode: String
  itemUnit: String

  comment: String

  monthlyConsumption: Float
  monthsOfSupply: Float

  supplyQuantity: Float
  openingQuantity: Float
  issuedQuantity: Float
  requestedQuantity: Float
  receivedQuantity: Float
  imprestQuantity: Float
  previousQuantity: Float
  calculatedQuantity: Float

  previousStockOnHand: Float
  closingQuantity: Float

  stockAdditions: Float
  stockLosses: Float
  expiredQuantity: Float

  otherPartyClosingQuantity: Float
}

union RequisitionLinesResponse = ConnectorError | RequisitionLineConnector

union StocktakeLinesResponse = ConnectorError | StocktakeLineConnector

type StocktakeLineConnector {
  totalCount: Int!
  nodes: [StocktakeLineNode!]
}

type RequisitionLineConnector {
  totalCount: Int!
  nodes: [RequisitionLineNode!]!
}

enum SupplierRequisitionNodeStatus {
  DRAFT
  SENT
  IN_PROGRESS
  FINALISED
}

enum CustomerRequisitionNodeStatus {
  NEW
  IN_PROGRESS
  FINALISED
}

union StocktakeResponse = StocktakeNode | NodeError
union StocktakesResponse = StocktakeConnector | NodeError
type StocktakeConnector {
  totalCount: Int!
  nodes: [StocktakeNode!]!
}

union RequisitionResponse = RequisitionNode | NodeError

union RequisitionLineResponse = RequisitionNode | NodeError

enum RequisitionNodeType {
  CUSTOMER_REQUISITION
  SUPPLIER_REQUISITION
}

union RequisitionsResponse = ConnectorError | RequisitionConnector

type RequisitionConnector {
  totalCount: Int!
  nodes: [RequisitionNode]!
}

input UpdateSupplierRequisitionInput {
  id: String!
  orderDate: String
  nameId: String
  comment: String
  theirReference: String
  color: String
}

input UpdateSupplierRequisitionLineInput {
  id: String!
  itemName: String
  itemCode: String
  itemUnit: String
  comment: String
  monthlyConsumption: Float
  monthsOfSupply: Float
  supplyQuantity: Float
  openingQuantity: Float
  issuedQuantity: Float
  requestedQuantity: Float
  receivedQuantity: Float
  imprestQuantity: Float
  previousQuantity: Float
  calculatedQuantity: Float

  previousStockOnHand: Float
  closingQuantity: Int

  stockAdditions: Float
  stockLosses: Float
  expiredQuantity: Float

  otherPartyClosingQuantity: Int
}

input UpdateCustomerRequisitionLineInput {
  id: String!
  itemName: String
  itemCode: String
  itemUnit: String

  comment: String

  monthlyConsumption: Float
  monthsOfSupply: Float

  supplyQuantity: Float
  openingQuantity: Float
  issuedQuantity: Float
  requestedQuantity: Float
  receivedQuantity: Float
  imprestQuantity: Float
  previousQuantity: Float
  calculatedQuantity: Float

  previousStockOnHand: Float
  closingQuantity: Int

  stockAdditions: Float
  stockLosses: Float
  expiredQuantity: Float

  otherPartyClosingQuantity: Int
}

input InsertSupplierRequisitionInput {
  id: String!
  orderDate: String
  otherPartyId: String!
  comment: String
  theirReference: String
  type: RequisitionNodeType
}

input UpdateStocktakeInput {
  id: String!
  stocktakeDate: String
  comment: String
  description: String
  status: StocktakeNodeStatus
}
union UpdateStocktakeResponse = NodeError | StocktakeNode
type UpdateStocktakeResponseWithId {
  id: String!
  response: UpdateStocktakeResponse
}

union InsertStocktakeResponse = NodeError | StocktakeNode
type InsertStocktakeResponseWithId {
  id: String!
  response: InsertStocktakeResponse
}

union DeleteStocktakeResponse = NodeError | DeleteResponse
type DeleteStocktakeResponseWithId {
  id: String!
  response: DeleteResponse
}

input InsertStocktakeInput {
  id: String!
  stocktakeDate: String
  comment: String
  description: String
}

input DeleteStocktakeInput {
  id: String!
}

input InsertSupplierRequisitionLineInput {
  id: String!
  itemId: String!
  requisitionId: String!
  itemName: String
  itemCode: String
  itemUnit: String

  comment: String

  monthlyConsumption: Float
  monthsOfSupply: Float

  supplyQuantity: Float
  openingQuantity: Float
  issuedQuantity: Float
  requestedQuantity: Float
  receivedQuantity: Float
  imprestQuantity: Float
  previousQuantity: Float
  calculatedQuantity: Float

  previousStockOnHand: Float
  closingQuantity: Int

  stockAdditions: Float
  stockLosses: Float
  expiredQuantity: Float

  otherPartyClosingQuantity: Int
}

input InsertCustomerRequisitionLineInput {
  id: String!
  itemId: String!
  requisitionId: String!
  itemName: String
  itemCode: String
  itemUnit: String

  comment: String

  monthlyConsumption: Float
  monthsOfSupply: Float

  supplyQuantity: Float
  openingQuantity: Float
  issuedQuantity: Float
  requestedQuantity: Float
  receivedQuantity: Float
  imprestQuantity: Float
  previousQuantity: Float
  calculatedQuantity: Float

  previousStockOnHand: Float
  closingQuantity: Int

  stockAdditions: Float
  stockLosses: Float
  expiredQuantity: Float

  otherPartyClosingQuantity: Int
}

input DeleteSupplierRequisitionInput {
  id: String!
}

input DeleteSupplierRequisitionLineInput {
  id: String!
}

input DeleteCustomerRequisitionLineInput {
  id: String!
}

union UpdateSupplierRequisitionResponse = NodeError | RequisitionNode
type UpdateSupplierRequisitionResponseWithId {
  id: String!
  response: UpdateSupplierRequisitionResponse
}

union UpdateSupplierRequisitionLineResponse = NodeError | RequisitionLineNode
type UpdateSupplierRequisitionLineResponseWithId {
  id: String!
  response: UpdateSupplierRequisitionLineResponse
}

union UpdateCustomerRequisitionLineResponse = NodeError | RequisitionLineNode
type UpdateCustomerRequisitionLineResponseWithId {
  id: String!
  response: UpdateCustomerRequisitionLineResponse
}

union InsertSupplierRequisitionResponse = NodeError | RequisitionNode
type InsertSupplierRequisitionResponseWithId {
  id: String!
  response: InsertSupplierRequisitionResponse
}

union InsertSupplierRequisitionLineResponse = NodeError | RequisitionLineNode
type InsertSupplierRequisitionLineResponseWithId {
  id: String!
  response: InsertSupplierRequisitionLineResponse
}

union InsertCustomerRequisitionLineResponse = NodeError | RequisitionLineNode
type InsertCustomerRequisitionLineResponseWithId {
  id: String!
  response: InsertSupplierRequisitionLineResponse
}

union DeleteSupplierRequisitionResponse = NodeError | DeleteResponse
type DeleteSupplierRequisitionResponseWithId {
  id: String!
  response: DeleteSupplierRequisitionResponse
}

union DeleteSupplierRequisitionLineResponse = NodeError | DeleteResponse
type DeleteSupplierRequisitionLineResponseWithId {
  id: String!
  response: DeleteSupplierRequisitionLineResponse
}

union DeleteCustomerRequisitionLineResponse = NodeError | DeleteResponse
type DeleteCustomerRequisitionLineResponseWithId {
  id: String!
  response: DeleteCustomerRequisitionLineResponse
}

input UpdateCustomerRequisitionInput {
  id: String!
  orderDate: String
  nameId: String
  comment: String
  theirReference: String
  color: String
}

input InsertCustomerRequisitionInput {
  id: String!
  orderDate: String
  otherPartyId: String!
  comment: String
  theirReference: String
  type: RequisitionNodeType
}

input DeleteCustomerRequisitionInput {
  id: String!
}

union UpdateCustomerRequisitionResponse = NodeError | RequisitionNode
type UpdateCustomerRequisitionResponseWithId {
  id: String!
  response: UpdateCustomerRequisitionResponse
}

union InsertCustomerRequisitionResponse = NodeError | RequisitionNode
type InsertCustomerRequisitionResponseWithId {
  id: String!
  response: InsertCustomerRequisitionResponse
}

union DeleteCustomerRequisitionResponse = NodeError | DeleteResponse
type DeleteCustomerRequisitionResponseWithId {
  id: String!
  response: DeleteCustomerRequisitionResponse
}

input BatchSupplierRequisitionInput {
  insertSupplierRequisitions: [InsertSupplierRequisitionInput!]
  updateSupplierRequisitions: [UpdateSupplierRequisitionInput!]
  deleteSupplierRequisitions: [DeleteSupplierRequisitionInput!]
  insertSupplierRequisitionLines: [InsertSupplierRequisitionLineInput!]
  updateSupplierRequisitionLines: [UpdateSupplierRequisitionLineInput!]
  deleteSupplierRequisitionLines: [DeleteSupplierRequisitionLineInput!]
}

input BatchCustomerRequisitionInput {
  insertCustomerRequisitions: [InsertCustomerRequisitionInput!]
  updateCustomerRequisitions: [UpdateCustomerRequisitionInput!]
  deleteCustomerRequisitions: [DeleteCustomerRequisitionInput!]
  insertCustomerRequisitionLines: [InsertCustomerRequisitionLineInput!]
  updateCustomerRequisitionLines: [UpdateCustomerRequisitionLineInput!]
  deleteCustomerRequisitionLines: [DeleteCustomerRequisitionLineInput!]
}

input BatchStocktakeInput {
  insertStocktakes: [InsertStocktakeInput!]
  updateStocktakes: [UpdateStocktakeInput!]
  deleteStocktakes: [DeleteStocktakeInput!]
  insertStocktakeLines: [InsertStocktakeLineInput!]
  updateStocktakeLines: [UpdateStocktakeLineInput!]
  deleteStocktakeLines: [DeleteStocktakeLineInput!]
}

type BatchCustomerRequisitionResponse {
  insertCustomerRequisitionLines: [InsertCustomerRequisitionLineResponseWithId!]
  updateCustomerRequisitionLines: [UpdateCustomerRequisitionLineResponseWithId!]
  deleteCustomerRequisitionLines: [DeleteCustomerRequisitionLineResponseWithId!]
  insertCustomerRequisitions: [InsertCustomerRequisitionResponseWithId!]
  updateCustomerRequisitions: [UpdateCustomerRequisitionResponseWithId!]
  deleteCustomerRequisitions: [DeleteCustomerRequisitionResponseWithId!]
}

type BatchSupplierRequisitionResponse {
  insertSupplierRequisitionLines: [InsertSupplierRequisitionLineResponseWithId!]
  updateSupplierRequisitionLines: [UpdateSupplierRequisitionLineResponseWithId!]
  deleteSupplierRequisitionLines: [DeleteSupplierRequisitionLineResponseWithId!]
  insertSupplierRequisitions: [InsertSupplierRequisitionResponseWithId!]
  updateSupplierRequisitions: [UpdateSupplierRequisitionResponseWithId!]
  deleteSupplierRequisitions: [DeleteSupplierRequisitionResponseWithId!]
}

type BatchStocktakeResponse {
  insertStocktakeLines: [InsertStocktakeLineResponseWithId!]
  updateStocktakeLines: [UpdateStocktakeLineResponseWithId!]
  deleteStocktakeLines: [DeleteStocktakeLineResponseWithId!]
  insertStocktakes: [InsertStocktakeResponseWithId!]
  updateStocktakes: [UpdateStocktakeResponseWithId!]
  deleteStocktakes: [DeleteStocktakeResponseWithId!]
}
